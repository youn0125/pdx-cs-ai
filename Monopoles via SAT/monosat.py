#!/usr/bin/python3
# Generate a SAT encoding for a Monopoles instance in DIMACS format
# http://www.satcompetition.org/2009/format-benchmarks2009.html
# to solve a Monopoles instance.
# Architecture referred from sudokugen.py
# https://github.com/pdx-cs-ai/sudoku-sat-py/blob/master/sudokugen.py
# Mi Yon Kim

import sys

# Given M monopoles and N rooms, return the atom
# corresponding to atom[m][n]. atom[m][n] stands for location of monopole.
def atom(m, n):
    return num_of_monopoles * n + m + 1

num_of_monopoles, num_of_rooms = int(sys.argv[1]), int(sys.argv[2])

# Keep a list of all the clauses.
clauses = []
def clause(c):
    clauses.append(c)

# Each monopole is placed in a room:
for r in range(num_of_monopoles):
    clause([atom(r, c) for c in range(num_of_rooms)])

# No monopole is in two places:
for r in range(num_of_monopoles):
    for c1 in range(num_of_rooms):
        for c2 in range(c1+1, num_of_rooms):
            clause([-atom(r, c1), -atom(r, c2)])

# Sums exclude monopoles:
for c in range(num_of_rooms):
    for r1 in range(num_of_monopoles):
        for r2 in range(r1+1, num_of_monopoles):
            if r1 + r2 + 1 >= num_of_monopoles:
                break
            clause([-atom(r1, c), -atom(r2, c), -atom(r1+r2+1, c)])

# Emit the problem description.
print("c", "generated by monosat")
print("p", "cnf", num_of_rooms*num_of_monopoles, len(clauses))
for c in clauses:
    for l in c:
        print(l, "", end="")
    print("0")


